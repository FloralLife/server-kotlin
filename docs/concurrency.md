# 동시성(Concurrency)

## 1. 프로세스 & 스레드 동시성 이슈

### 1.1 Race Condition
- **정의**: 두 개 이상의 프로세스(또는 스레드)가 공통 자원에 병렬적으로 접근하여, 실행 순서에 따라 결과가 달라지는 문제
- **예시**: 두 스레드가 하나의 자원을 동시에 수정하려고 할 때, 자원에 대한 접근이 동기화되지 않아 발생

### 1.2 Mutual Exclusion (상호 배제)
- **목적**: Race Condition을 막기 위해, 공용 데이터에 동시에 접근하지 못하도록 하는 것
- **방법**: 한 프로세스(스레드)가 자원을 점유 중이면, 다른 프로세스(스레드)가 접근하지 못하도록 배타적으로 잠금을 거는 방식

### 1.3 Deadlock (교착상태)
- **정의**: 두 프로세스가 각각 다른 자원을 점유하고, 서로 상대방이 가진 자원을 기다리는 상황
- **예시**
  - 프로세스 A: 자원1 점유, 자원2 대기
  - 프로세스 B: 자원2 점유, 자원1 대기

### 1.4 Starvation (기아)
- 한 프로세스가 우선순위가 낮아 자원을 계속 획득하지 못하고 무기한 대기 상태에 빠지는 문제

### 1.5 Resource Contention
- 여러 프로세스(또는 스레드)가 공유 자원을 놓고 충돌(conflict)하는 상황
- 한 프로세스가 자원 사용 중이면, 다른 프로세스들은 대기해야 하므로 병목현상 발생

---

## 2. 동시성 제어 기법

### 2.1 Mutex (뮤텍스)
- **정의**: 공유 자원에 대한 접근을 제어하기 위해 *키와 유사한 객체*를 두고, 오직 이를 소유한 프로세스만 접근 가능
- **비유**: 식당 화장실 키가 하나만 있어서, 키를 가진 사람만 화장실(공유자원)에 들어갈 수 있는 상황

### 2.2 Semaphore (세마포어)
- **정의**: 공유 자원에 접근할 수 있는 프로세스(스레드)의 *최대 개수*를 정해서 동시 접근을 제어
- **비유**: 주차장 주차 가능 대수로 접근 가능 횟수를 관리

---

## 3. 데이터베이스 격리 레벨

### 3.1 READ UNCOMMITTED
- **특징**: 커밋되지 않은 변경 사항도 다른 트랜잭션에서 볼 수 있음
- **문제점**: Dirty Read 발생 (아직 완료되지 않은 데이터를 읽을 수 있음)

### 3.2 READ COMMITTED
- **특징**:
  - **오라클 기본** 격리 수준
  - 커밋된 데이터만 읽음 → Dirty Read는 발생하지 않음
- **부연**: 하나의 트랜잭션에서 데이터를 조회할 때, 이미 커밋 완료된 최신 데이터를 보여줌

#### Undo log
- **역할**: UPDATE, DELETE로 변경된 **이전 데이터(백업본)**를 보관
- **이유**:
  1. 트랜잭션 롤백 시 복원
  2. 트랜잭션 격리 수준을 유지하며 동시성을 높이기 위함

### 3.3 NON-REPEATABLE READ
- **정의**: 한 트랜잭션에서 같은 조회 쿼리를 실행해도, 실행 시점에 따라 결과가 달라지는 문제
- **발생 레벨**: READ UNCOMMITTED, READ COMMITTED

### 3.4 REPEATABLE READ
- **특징**:
  - *MySQL InnoDB 기본* 격리 수준
  - 동일 트랜잭션 내에서 같은 쿼리를 실행하면, 결과가 변하지 않도록 보장 → NON-REPEATABLE READ 문제 해결
  - Undo 영역의 **여러 버전** 중에서 트랜잭션 시작 시점을 기준으로 자신보다 **작은 트랜잭션 번호**만 반영된 데이터를 사용

### 3.5 PHANTOM READ
- **정의**: 한 트랜잭션이 같은 조건으로 두 번 이상 조회할 때, *사이에 새로운 행이 삽입*되어 결과 집합이 달라지는 현상
- **발생 레벨**: REPEATABLE READ에서도 발생 가능
- **원인**: 새로 삽입된 행은 Undo에 과거 정보가 없어, 과거 시점 데이터를 재구성할 수 없기 때문
- **해결 (MySQL InnoDB)**:
  - **Next-Key Lock** (레코드 락 + 갭 락)을 통해 인덱스 범위 내 레코드 삽입을 차단
  - Undo log, MVCC 등을 통해 트랜잭션 버전을 확인

### 3.6 SERIALIZABLE
- **특징**:
  - 읽기, 쓰기 모든 작업이 락을 획득해야 함 → 동시성 가장 낮음
  - 가장 엄격하지만 성능 저하가 큼

---

## 4. 동시성 제어 (Lock) 기법

### 4.1 `synchronized` (Java)
- **정의**: 메서드나 블록에 명시하여, 해당 영역에는 하나의 스레드만 접근 가능하게 하는 키워드
- **한계**: 하나의 프로세스 내부에서만 동작 → 서버가 여러 대이면 사용 불가능

### 4.2 Pessimistic Lock (비관적 락)
- **정의**: 데이터 접근 시 무조건 락을 걸어, 다른 트랜잭션의 접근을 차단
- **장점**: 동시성 문제 발생을 원천 차단
- **단점**: 데드락 가능성, 성능 저하

### 4.3 Optimistic Lock (낙관적 락)
- **정의**: 버전을 이용하여 변경 시점에 충돌이 있는지 검사한 뒤, 충돌 시 롤백 또는 재시도
- **장점**: 락을 오래 유지하지 않아 데드락 우려가 적음
- **단점**: 충돌이 자주 발생하면 잦은 재시도로 오버헤드 증가

### 4.4 Named Lock
- **특징**:
  - `GET_LOCK('name', timeout)` 형태로 락을 획득 (MySQL 예시)
  - 트랜잭션 종료 시 자동 해제되지 않을 수 있음
  - 분산 락 구현에 활용 가능
  - 구현이 다소 복잡

### 4.5 S-Lock (Shared Lock)
- **정의**: 여러 트랜잭션이 동시에 읽기 가능, 쓰기(수정)는 불가능
- **특징**:
  - 트랜잭션들이 동시에 S-lock 획득 가능
  - X-lock이 걸려 있으면 S-lock 획득 불가

### 4.6 X-Lock (Exclusive Lock)
- **정의**: 쓰기 연산을 위해 필요한 락, 해당 자원을 단독으로 사용
- **특징**:
  - 동시에 다른 트랜잭션이 S-lock, X-lock을 얻을 수 없음
  - 한 트랜잭션이 X-lock을 가지고 있으면 독점적 점유 상태

---

## 5. 분산 락

### 5.1 분산 락 개요
- 여러 서버(프로세스)가 공통 자원(또는 임계영역)을 제어하기 위한 기술
- **목적**: 한 서버에서 락을 획득하면, 다른 서버(프로세스)가 동일 자원에 동시에 접근하지 못하도록 보장

### 5.2 Redis 분산 락이 가져야 할 세 가지 속성
1. **Safety Property (Mutual Exclusion)**
  - 어떤 시점에도 단 하나의 클라이언트만 특정 리소스에 대한 락을 보유
2. **Liveness Property A: Deadlock Free**
  - 락을 획득한 클라이언트가 실패하여 락을 반납하지 못하는 경우에도, 이후 다른 클라이언트들이 락을 획득할 수 있어야 함
3. **Liveness Property B: Fault Tolerance**
  - 여러 Redis 노드가 존재할 때, 일부 노드가 장애가 나더라도 정상적으로 락을 획득·해제 가능

### 5.3 Lettuce로 구현한 분산 락
- `setnx` (set if not exist)를 이용한 스핀락 방식
- **특징**:
  - 사용자가 직접 로직(타임아웃, 횟수제한 등) 구현
  - 락 획득 실패 시 무한 루프 돌 위험 → Redis 부하 가능
  - Low-level API → 가벼움

### 5.4 Redisson
- **특징**:
  - `pub/sub` 사용, 락 해제 이벤트를 subscribe 중인 클라이언트가 감지 후, 락 획득 시도
  - Redis에 지속적으로 락 획득 요청을 보내지 않으므로 부하가 적음
  - 라이브러리는 무겁지만 구현 편의성 높음

### 5.5 Redis Redlock 알고리즘
- **개념**: 독립적인 Redis 마스터 노드 N대를 운영, 그중 과반수(N/2+1)에서 락 획득 시 분산 락 획득 성공으로 간주
- **절차**:
  1. N대 노드에 동시에 `setnx` 요청
  2. N/2+1 대 이상에서 성공 → 락 획득
  3. 실패 → 모든 노드에 락 해제 요청 & random interval 후 재시도
- **주의**:
  - 시스템 클록에 따른 *clock drift*나 애플리케이션 중지 시 완전 보장이 어려울 수 있음
  - 완전한 안정성이 필요하다면 Zookeeper 등 합의 시스템 고려

---

## 6. 정리
- MySQL은 REPEATABLE READ 레벨을 기본으로 사용하며 MySQL의 스토리지 엔진 InnoDB에서는 Undo 로그와 MVCC를 통해 Phantom Read 문제를 방지한다.
- 낙관적 락은 충돌이 적게 일어나고 한번의 요청만 성공해야 할 경우에 적합하다.
- 비관적 락은 충돌이 자주 일어나고 반드시 성공해야 할 경우에 적합하다.
- 레디스 분산락은 여러 프로세스가 동일 자원에 접근할 때 사용하기 적당한 솔루션이며 `Redisson`라이브러리를 사용하기 좋지만, 다수의 레디스 노드에서는 완벽하지 않을 수 있다.
